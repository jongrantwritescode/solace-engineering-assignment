# Cursor Rules

## Git Workflow Rule
When the user requests 'xgit workflow':

1. **Stage Files**: Automatically execute `git add .` to stage all changes
2. **Generate Commit Message**: Create a meaningful, conventional, and succinct commit message based ONLY on the staged files and current conversation context.  Only facts, no assertions or value statements.
3. **Show for Review**: Display the proposed commit message and ask for user review
4. **Wait for Approval**: Do NOT commit or push until user explicitly approves
5. **User Options**: User can either:
   - Approve: "commit and push" or "go ahead"
   - Modify: Provide feedback on the commit message
   - Reject: Cancel the operation

**IMPORTANT**: The commit message must accurately reflect ONLY what is staged for commit, not previous work or uncommitted changes.

### Git Workflow Safety Rule
**IMPORTANT**: Do NOT execute git workflow unless the user explicitly types "git workflow" in the chat. This prevents accidental commits and ensures user control over all git operations.

### Commit Message Guidelines
- Use conventional commit format: `type(scope): description`
- Types: feat, fix, docs, style, refactor, test, chore
- Be descriptive but concise
- Include scope when relevant (e.g., feat(components), fix(accessibility))
- Reference the main work accomplished

### Example Workflow
1. User: "git workflow"
2. Assistant: Stages files, shows commit message
3. User: Reviews and either approves or provides feedback
4. Assistant: Executes git commit and push only after approval

## TDD Workflow Rule
When the user requests code creation, follow this strict TDD workflow:

### **Phase 1: Planning (No Code Written)**
1. **Present Plan First**: Show a detailed plan with no code written or files changed
2. **Wait for Approval**: Do NOT proceed until user explicitly approves the plan
3. **Plan Must Include**: File structure, test organization, component/resolver design, dependencies

### **Phase 2: Test Scaffolding (Tests as Specification)**
1. **Write Tests First**: Create only the test structure with `describe` and `it` blocks
2. **Tests as Specification**: Each test should read like a requirement specification
3. **No Implementation**: Tests should fail (red) - no actual code or test logic yet
4. **Clear Structure**: Tests should be readable top-to-bottom as a feature specification
5. **New Code Only**: Only write tests for new functionality being added, not for existing code being modified
6. **Test Framework**: Use vitest for all testing (describe, it, expect, beforeEach, etc.)

### **Phase 3: Test Refinement (User-Driven Changes)**
1. **User Controls Tests**: User can request changes to test structure, descriptions, or organization
2. **Immediate Updates**: Make test changes as requested without waiting for approval
3. **Preserve Intent**: Maintain the overall test structure and organization

### **Phase 4: Implementation (Test-Locked)**
1. **User Approval Required**: Only proceed when user says "implement" or equivalent
2. **Test Structure Locked**: Cannot change test structure, descriptions, or organization
3. **Implementation Only**: Write test implementation and code under test
4. **Problem Resolution**: If test structure creates unsolvable implementation problems:
   - STOP implementation
   - Explain the problem clearly
   - Wait for user direction on how to proceed
   - Do NOT modify tests without explicit permission

### **Important TDD Guidelines:**
- **New Features**: Follow full TDD workflow for completely new functionality
- **Existing Code Modifications**: Only add tests for the specific new behavior being added
- **Refactoring**: Do not rewrite tests for existing functionality unless explicitly requested
- **Incremental Development**: Focus tests on the delta of new functionality, not the entire feature

### **Example Workflow:**
```
User: "Create a user dashboard component"
Assistant: [Shows plan with no code]
User: "Approved"
Assistant: [Writes test scaffolding only]
User: "Change the third test to..."
Assistant: [Updates test immediately]
User: "implement"
Assistant: [Writes test implementation and component code]
```

## Backend Development Rule
When working with Node.js backend:

1. **Use TypeScript**: Write all backend code in TypeScript with proper type definitions
2. **Follow Express/Fastify Patterns**: Use proper middleware, route organization, and error handling
3. **Database Design**: Use PostgreSQL with proper relational design, migrations, and connection pooling
4. **Add Comprehensive Tests**: Create test files for all routes, services, and database operations
5. **API Design**: Follow RESTful principles with proper HTTP status codes and error responses
6. **Type Safety**: Ensure all API endpoints have proper request/response type definitions
7. **Environment Configuration**: Use environment variables for database connections and API keys

## Frontend Development Rule
When working in the frontend (Next.js app):

1. **Use Tailwind CSS**: Prioritize Tailwind utility classes over custom CSS
2. **Follow Next.js Patterns**:
   - **Pages**: Use App Router with `page.tsx` files in feature directories
   - **Components**: Place reusable components in `components/` subfolder
   - **Types**: One type definition per file in `types/` subfolder (e.g., `user.types.ts`, `dashboard.types.ts`)
   - **Module Structure**: Organize features into modules with `types/`, `components/`, `pages/`, and `index.ts`
3. **Add Tests**: Create test files for all components and pages using React Testing Library
4. **Layout Consistency**: Use Tailwind's grid and flexbox utilities for responsive layouts
5. **Styling**: Leverage Tailwind's design system, use CSS modules only when necessary
6. **Next.js Best Practices**: Use proper routing, API routes, and server-side rendering when beneficial

## Testing Rule (Sandy Metz Style)
When creating tests:

1. **Structure**: Use "When..., with..., should..." format where:
   - **When**: Describes the action/behavior being tested (clusters by behavior)
   - **With**: Describes the preconditions/context/setup
   - **Should**: Describes the expected outcome/assertion

2. **Test Organization**:
   - Use `beforeEach` to group related tests together
   - Group tests by behavior, not by method
   - Each test should have exactly one assertion/expect
   - Nest contexts to avoid overly long test names

3. **What to Test** (Sandy Metz Philosophy):
   - **Test Inputs and Outputs**: Only test public interface behavior
   - **Test State Changes**: Verify changes to observable state
   - **Test Return Values**: Verify correct values are returned
   - **DO NOT Test**: Helper functions, private methods, or internal implementation details

4. **Naming Convention**:
   - **describe**: `When [action]` (e.g., "When creating an order")
   - **describe**: `with [condition]` (e.g., "with a valid user")
   - **it**: `should [outcome]` (e.g., "should return 201 with an order id")

4. **Test Examples**:
   ```typescript
   describe('UserResolver', () => {
     let resolver: UserResolver;
     
     beforeEach(() => {
       resolver = new UserResolver();
     });
     
     describe('When getting a user', () => {
       describe('with a valid user ID', () => {
         let userId: string;
         let result: any;
         
         beforeEach(async () => {
           userId = 'user1';
           result = await resolver.getUser(userId);
         });
         
         it('should return user with matching ID', () => {
           expect(result.id).toBe(userId);
         });
         
         it('should return user with firstName property', () => {
           expect(result).toHaveProperty('firstName');
         });
         
         it('should return user with lastName property', () => {
           expect(result).toHaveProperty('lastName');
         });
         
         it('should return user with email property', () => {
           expect(result).toHaveProperty('email');
         });
       });
       
       describe('with an invalid user ID', () => {
         let userId: string;
         
         beforeEach(() => {
           userId = 'invalid-user';
         });
         
         it('should return null', async () => {
           const result = await resolver.getUser(userId);
           expect(result).toBeNull();
         });
       });
     });
   });
   ```

## TypeScript Configuration Rule
When working with TypeScript configuration files:

1. **Module Syntax**: Use ES modules with proper import/export syntax
2. **Path Mapping**: Ensure proper path mapping and module resolution for both frontend and backend
3. **Strict Mode**: Enable strict TypeScript settings for better type safety
4. **Next.js Integration**: Configure TypeScript for Next.js with proper page and API route types
5. **Build Compatibility**: Ensure TypeScript compilation works with both Node.js and Next.js runtime
6. **Type Definitions**: Use proper type definitions for external libraries and APIs

## Error Handling & Debugging Rule
When encountering runtime errors:

1. **Import Issues**: Check import paths and file extensions first
2. **Compilation vs Runtime**: Verify TypeScript compilation vs runtime execution differences
3. **Database Connections**: Check PostgreSQL connection strings and environment variables
4. **Next.js Issues**: Verify proper page structure and API route configuration
5. **Module Resolution**: Check for ES module vs CommonJS compatibility issues
6. **Type Mismatches**: Verify API request/response types match database schema
7. **Docker Issues**: Check container networking and volume mounts

## Module Architecture Rule
When creating new features:

1. **Follow Established Pattern**: Use the established module structure: `types/`, `components/`, `pages/`, `index.ts`
2. **Export Strategy**: Export everything through the module's `index.ts` file
3. **Grouping**: Keep related functionality grouped together in logical modules
4. **Naming Conventions**: Use consistent naming conventions across all modules
5. **File Organization**: Maintain clear separation between types, components, and pages
6. **Import Paths**: Use relative imports within modules, absolute imports from module index files
7. **Database Schema**: Organize database tables and migrations logically by feature domain

## Docker Development Rule
When working with Docker:

1. **Multi-stage Builds**: Use multi-stage Dockerfiles for production builds
2. **Environment Variables**: Use `.env` files and Docker Compose for environment configuration
3. **Volume Management**: Properly configure volumes for development and production
4. **Network Configuration**: Set up proper networking between containers
5. **Health Checks**: Include health checks for database and application containers
6. **Security**: Run containers as non-root users when possible
7. **Optimization**: Minimize image layers and use appropriate base images

## Database Development Rule
When working with PostgreSQL:

1. **Schema Design**: Use proper normalization and relational design principles
2. **Migrations**: Create versioned database migrations for all schema changes
3. **Connection Pooling**: Implement proper connection pooling for production
4. **Indexing**: Add appropriate indexes for query performance
5. **Data Types**: Use appropriate PostgreSQL data types (UUID, JSONB, etc.)
6. **Transactions**: Use transactions for multi-step database operations
7. **Backup Strategy**: Implement regular database backups and recovery procedures


## Project Context
This is the CureBase project with:
- Frontend: React + TypeScript + Next.js + Tailwind CSS
- Backend: Node.js + TypeScript + Express/Fastify
- Database: PostgreSQL (preferred) with proper relational design
- Infrastructure: Docker for containerization
- Modern web development with full-stack TypeScript
